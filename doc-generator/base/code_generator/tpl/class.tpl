<?php

/**
 * Class SeleniumTestCaseDoc
 *
 * This class provides extended documentation (phpDoc) for phpunit-selenium methods
 * (override documentation of methods {@link PHPUnit_Extensions_SeleniumTestCase}).
 * Class used for easy development of tests in IDE (like phpStorm or NetBeans).
 *
 *
 * @see http://release.seleniumhq.org/selenium-core/1.0.1/reference.html   Selenium commands documentation
 * @see https://github.com/IStranger/phpunit-selenium-doc
 * @see http://istranger.github.io/phpunit-selenium-doc/a00001.html        Html-doccumentation (generated from this class)
 *
 * @author  G.Azamat <m@fx4web.com>
 * @date    %date%
 */
trait SeleniumTestCaseDoc_AutoGenerated
{
    // private variables doc_* only for separate phpDoc by section (and for links)

    /**
     * <h3>Element Locators</h3>
     *
     * Element Locators tell Selenium which HTML element a command refers to. The format of a locator is:
     * <b> locatorType=argument </b>
     *
     * We support the following strategies for locating elements (and locator types):
     *      + <b>identifier=id </b><br/>
     *          Select the element with the specified @ id attribute. If no match is found, select the first element whose
     *          @ name attribute is id. This is normally the default; see below.
     *      + <b>id=id</b><br/>
     *          Select the element with the specified @ id attribute.
     *      + <b>name=name </b><br/>
     *          Select the first element with the specified @ name attribute. <br/>
     *          -- username <br/>
     *          -- name=username  <br/>
     *          -- name=flavour value=chocolate <br/>
     *              The name may optionally be followed by one or more element-filters, separated from the name by
     *              whitespace. If the filterType is not specified, value is assumed. (see "Element Filters" below)
     *      + <b>dom=javascriptExpression </b><br/>
     *          Find an element by evaluating the specified string. This allows you to traverse the HTML Document Object
     *          Model using JavaScript. Note that you must not return a value in this string; simply make it the last
     *          expression in the block.  <br/>
     *          -- dom=document.forms['myForm'].myDropdown  <br/>
     *          -- dom=document.images[56] <br/>
     *          -- dom=function foo() { return document.links[1]; }; foo(); <br/>
     *      + <b>xpath=xpathExpression </b><br/>
     *          Locate an element using an XPath expression. <br/>
     *          -- xpath=//img[@ alt='The image alt text'] <br/>
     *          -- xpath=//table[@ id='table1']//tr[4]/td[2] <br/>
     *          -- xpath=//a[contains(@ href,'#id1')] <br/>
     *          -- xpath=//a[contains(@ href,'#id1')]/@ class <br/>
     *          -- xpath=(//table[@ class='stylee'])//th[text()='theHeaderText']/../td <br/>
     *          -- xpath=//input[@ name='name2' and @ value='yes'] <br/>
     *          -- xpath=//*[text()="right"] <br/>
     *      + <b>link=textPattern </b><br/>
     *          Select the link (anchor) element which contains text matching the specified {@link $doc_String_match_Patterns pattern}. <br/>
     *           -- link=The link text <br/>
     *      + <b>css=cssSelectorSyntax </b><br/>
     *          Select the element using css selectors. Please refer to CSS2 selectors, CSS3 selectors for more
     *          information. You can also check the TestCssLocators test in the selenium test suite for an example of
     *          usage, which is included in the downloaded selenium core package. <br/>
     *           -- css=a[href="#id3"] <br/>
     *           -- css=span#firstChild + span <br/>
     *              Currently the css selector locator supports all css1, css2 and css3 selectors except namespace in css3,
     *              some pseudo classes(:nth-of-type, :nth-last-of-type, :first-of-type, :last-of-type, :only-of-type,
     *              :visited, :hover, :active, :focus, :indeterminate) and pseudo elements(::first-line, ::first-letter,
     *              ::selection, ::before, ::after). <br/>
     *      + <b>ui=uiSpecifierString </b><br/>
     *          Locate an element by resolving the UI specifier string to another locator, and evaluating it. See the
     *          Selenium UI-Element Reference for more details. <br/>
     *           -- ui=loginPages::loginButton() <br/>
     *           -- ui=settingsPages::toggle(label=Hide Email) <br/>
     *           -- ui=forumPages::postBody(index=2)//a[2] <br/> <br/>
     *
     *  Without an explicit locator prefix, Selenium uses the following <b>default</b> strategies:
     *      + <b>dom</b>, for locators starting with "document." <br/>
     *      + <b>xpath</b>, for locators starting with "//" <br/>
     *      + <b>identifier</b>, otherwise <br/>
     */
    private $doc_Element_Locators;

    /**
     * <h3>Element Filters</h3>
     *
     * Element filters can be used with a locator to refine a list of candidate elements. They are currently used only in
     * the 'name' element-locator. <br/> Filters look much like locators, ie. <b>filterType=argument</b>
     *
     * Supported element-filters are: <br/>
     * + <b>value=valuePattern </b><br/>
     *      Matches elements based on their values. This is particularly useful for refining a list of similarly-named
     *      toggle-buttons. <br/>
     * + <b>index=index </b><br/>
     *      Selects a single element based on its position in the list (offset from zero). <br/>
     */
    private $doc_Element_Filters;

    /**
     * <h3>String-match Patterns</h3>
     *
     * Various Pattern syntaxes are available for matching string values:
     *      + <b>glob:pattern </b><br/>
     *              Match a string against a "glob" (aka "wildmat") pattern. "Glob" is a kind of limited regular-expression
     *              syntax typically used in command-line shells. In a glob pattern, "*" represents any sequence of
     *              characters, and "?" represents any single character. Glob patterns match against the entire string.
     *              <br/>
     *      + <b>regexp:regexp </b><br/>
     *              Match a string using a regular-expression. The full power of JavaScript regular-expressions is
     *              available. <br/>
     *      + <b>regexpi:regexpi </b><br/>
     *              Match a string using a case-insensitive regular-expression. <br/>
     *      + <b>exact:string </b><br/>
     *              Match a string exactly, verbatim, without any of that fancy wildcard stuff. <br/>
     *
     * <p>If no pattern prefix is specified, Selenium assumes that it's a "glob" pattern.</p>
     *
     * <p>For commands that return multiple values (such as verifySelectOptions), the string being matched is a
     * comma-separated list of the return values, where both commas and backslashes in the values are backslash-escaped.
     * When providing a pattern, the optional matching syntax (i.e. glob, regexp, etc.) is specified once,
     * as usual, at the beginning of the pattern.</p>
     */
    private $doc_String_match_Patterns;

    /**
     * <h3>Stored Variables and Javascript evaluation</h3>
     *
     * <p>All Selenium command parameters can be constructed using both simple variable substitution as well as full
     * javascript. Both of these mechanisms can access previously stored variables, but do so using different syntax.</p>
     *
     * <h4>Stored Variables</h4>
     *
     * <p>The commands <em>store</em>, <em>storeValue</em> and <em>storeText</em> can be used to store a variable
     * value for later access. Internally, these variables are stored in a map called "storedVars",
     * with values keyed by the variable name. These commands are documented in the command reference.</p>
     *
     * <h4>Variable substitution</h4>
     *
     * <p>Variable substitution provides a simple way to include a previously stored variable in a
     * command parameter. This is a simple mechanism, by which the variable to substitute is indicated
     * by ${variableName}. Multiple variables can be substituted, and intermixed with static text.</p>
     *
     * <h4>Example:</h4>
     *
     * <pre><code>
     *      $this->storeTitle('pageTitle');
     *      $this->storeText('css=.text','elementText');
     *      $this->store('fullPageTitle', '{$pageTitle} -- ${elementText}');
     *      $this->type('textElement', 'Page title is: ${fullPageTitle}');
     * </code></pre>
     *
     * <h4>Javascript evaluation</h4>
     *
     * <p>Javascript evaluation provides the full power of javascript in constructing a command parameter.
     * To use this mechanism, the <em>entire</em> parameter value must be prefixed by
     * 'javascript{' with a trailing '}'. The text inside the braces is evaluated as a javascript expression,
     * and can access previously stored variables using the <em>storedVars</em> map detailed above.
     * Note that variable substitution cannot be combined with javascript evaluation.</p>
     *
     * <h4>Example:</h4>
     *
     * <pre><code>
     *      $this->store('javascript{'merchant' + (new Date()).getTime()}', 'merchantId');
     *      $this->type('textElement', 'javascript{storedVars['merchantId'].toUpperCase()}');
     * </code></pre>
     *
     */
    private $doc_Stored_Variables;

%methods%

    /**
     * Calls parent implementation of specified nonstatic method (from the parent class)
     *
     * @param string $currentMethodName  Name of current method (from current called object), see __METHOD__ constant
     * @param array  $args               Indexed array of arguments
     *
     * @return mixed
     */
    private function _callParentMethod($currentMethodName, $args)
    {
        $currentMethodName = explode('::', $currentMethodName)[1];
        return call_user_func_array('parent::' . $currentMethodName, $args);
    }
}